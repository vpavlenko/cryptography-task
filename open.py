#!/usr/bin/env python3s

from math import gcd

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    return b, x, y

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        return None  # modular inverse does not exist
    else:
        return x % m


# primes are generated by http://www.numberempire.com/primenumbers.php


# Diffie-Hellman

p = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000283
g = 17
# a = ...
# g_a = pow(g, a, p)
g_a = 1700625897271985794423019193826890081036584258931139530090340385905784532093207865379761844276125891139589085892977677722687746


# RSA

# p = ...
# q = ...
# n = p * q
n = 150045832057560449811845306756186228339401161050790479981004412521368342965753568774303610518805075858126235672715081831257200139668150211897579104248146446571553547053369396796524742032982070145084374690898523849693591282140112400881444744300254005879
# phi_n = (p - 1) * (q - 1)
e = 17
# d = modinv(e, phi_n)
# assert e * d % phi_n == 1
